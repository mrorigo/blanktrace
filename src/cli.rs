// src/cli.rs
use crate::db::Database;
use anyhow::Result;
use clap::{Parser, Subcommand};

#[derive(Parser)]
#[command(name = "blanktrace")]
#[command(author = "Generated by Antigravity")]
#[command(version = "0.1.0")]
#[command(about = "A Rust MITM proxy that randomizes fingerprints and blocks trackers")]
pub struct Cli {
    #[command(subcommand)]
    pub command: Option<Commands>,
}

#[derive(Subcommand)]
pub enum Commands {
    /// Show basic statistics from the SQLite DB
    Stats,
    /// List top tracked domains (default 10)
    Domains {
        #[arg(short, long)]
        limit: Option<usize>,
    },
    /// Export the DB to a JSON file
    Export {
        #[arg(short, long)]
        file: String,
    },
    /// Add a domain to the whitelist
    Whitelist {
        #[arg(short, long)]
        domain: String,
        #[arg(short, long)]
        reason: Option<String>,
    },
    /// Manually block a domain
    Block {
        #[arg(short, long)]
        domain: String,
    },
}

/// Execute a management subcommand without starting the proxy.
pub async fn handle_management_cmd(cmd: Commands, db_path: String) -> Result<()> {
    let db = Database::new(&db_path)?;

    match cmd {
        Commands::Stats => {
            println!("=== BlankTrace Statistics ===\n");

            let conn = db.get_conn().lock().await;

            // Total requests
            let total_requests: i64 =
                conn.query_row("SELECT COUNT(*) FROM request_log", [], |row| row.get(0))?;
            println!("Total Requests: {}", total_requests);

            // Unique domains
            let unique_domains: i64 = conn.query_row(
                "SELECT COUNT(DISTINCT domain) FROM request_log",
                [],
                |row| row.get(0),
            )?;
            println!("Unique Domains: {}", unique_domains);

            // Blocked domains
            let blocked_count: i64 = conn.query_row(
                "SELECT COUNT(*) FROM tracking_domains WHERE blocked = 1",
                [],
                |row| row.get(0),
            )?;
            println!("Blocked Domains: {}", blocked_count);

            // Whitelisted domains
            let whitelist_count: i64 =
                conn.query_row("SELECT COUNT(*) FROM whitelist", [], |row| row.get(0))?;
            println!("Whitelisted Domains: {}", whitelist_count);

            println!("\n=== Top 10 Most Requested Domains ===");
            let mut stmt = conn.prepare(
                "SELECT domain, COUNT(*) as count FROM request_log 
                 GROUP BY domain ORDER BY count DESC LIMIT 10",
            )?;
            let domains = stmt.query_map([], |row| {
                Ok((row.get::<_, String>(0)?, row.get::<_, i64>(1)?))
            })?;

            for (i, domain) in domains.enumerate() {
                let (domain, count) = domain?;
                println!("  {}. {} ({} requests)", i + 1, domain, count);
            }
        }
        Commands::Domains { limit } => {
            let top = db.get_top_domains(limit.unwrap_or(10)).await?;
            println!("Top tracked domains:");
            for (domain, hits) in top {
                println!("{domain}: {hits}");
            }
        }
        Commands::Export { file } => {
            println!("Exporting database to {}...", file);

            let conn = db.get_conn().lock().await;

            // Export as JSON
            let mut export_data = serde_json::json!({
                "export_time": chrono::Utc::now().to_rfc3339(),
                "requests": [],
                "tracking_domains": [],
                "whitelist": []
            });

            // Export requests
            let mut stmt = conn.prepare("SELECT domain, path, user_agent, client_ip, timestamp FROM request_log ORDER BY timestamp DESC LIMIT 1000")?;
            let requests: Vec<serde_json::Value> = stmt
                .query_map([], |row| {
                    Ok(serde_json::json!({
                        "domain": row.get::<_, String>(0)?,
                        "path": row.get::<_, String>(1)?,
                        "user_agent": row.get::<_, String>(2)?,
                        "client_ip": row.get::<_, String>(3)?,
                        "timestamp": row.get::<_, String>(4)?
                    }))
                })?
                .collect::<Result<Vec<_>, _>>()?;
            export_data["requests"] = serde_json::json!(requests);

            // Export tracking domains
            let mut stmt =
                conn.prepare("SELECT domain, hit_count, blocked FROM tracking_domains")?;
            let domains: Vec<serde_json::Value> = stmt
                .query_map([], |row| {
                    Ok(serde_json::json!({
                        "domain": row.get::<_, String>(0)?,
                        "hit_count": row.get::<_, i64>(1)?,
                        "blocked": row.get::<_, bool>(2)?
                    }))
                })?
                .collect::<Result<Vec<_>, _>>()?;
            export_data["tracking_domains"] = serde_json::json!(domains);

            // Export whitelist
            let mut stmt = conn.prepare("SELECT domain, reason, added_at FROM whitelist")?;
            let whitelist: Vec<serde_json::Value> = stmt
                .query_map([], |row| {
                    Ok(serde_json::json!({
                        "domain": row.get::<_, String>(0)?,
                        "reason": row.get::<_, Option<String>>(1)?,
                        "added_at": row.get::<_, String>(2)?
                    }))
                })?
                .collect::<Result<Vec<_>, _>>()?;
            export_data["whitelist"] = serde_json::json!(whitelist);

            // Write to file
            std::fs::write(&file, serde_json::to_string_pretty(&export_data)?)?;
            println!("✓ Export complete!");
        }
        Commands::Whitelist { domain, reason } => {
            db.add_whitelist(&domain, reason.as_deref()).await?;
            println!("✓ Added {} to whitelist", domain);
        }
        Commands::Block { domain } => {
            db.manual_block(&domain).await?;
            println!("✓ Blocked {}", domain);
        }
    }

    Ok(())
}
